/*! BCD v1.0.0 | (c) Tencent, Inc. | MIT License */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["BCD"] = factory();
	else
		root["BCD"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @module {object} bcd 对zepto的MVC扩展。
 * @description 该模块是框架核心，严格遵从奥卡姆剃刀原理:如无必要,勿增实体。增加了zepto对象的方法：
 * <p><a href="#~bindEvent">bindEvent   事件绑定</a></p>
 * <p><a href="#~setView">setView    设置为view视图</a></p>
 * <p><a href="#~reset">reset    重新渲染view</a></p>
 * <p><a href="#~getViewOption">getViewOption   获取view设置</a></p>
 * <p><a href="#~getData">getData    取出用于渲染view模板的数据</a></p>
 * <p><a href="#~setData">setData    用新数据渲染view模板</a></p>
 * <p><a href="#~addView">addView    为容器添加view</a></p>
 * <p><a href="#~getPage">getPage    获得zepto元素所在的页面容器</a></p>
 * <p><a href="#~getView">getView     获得zepto元素所在的view</a></p>
 * @return {object} 方法集合
 * @property {function} app <a href="#~app">app程序入口</a>
 * @property {function} addEvent <a href="#~addEvent">注册新事件（或称“指令”）</a>
 * @property {function} go <a href="#~go">页面跳转（所有页面跳转都应该使用该函数）</a>
 * @property {function} extendState <a href="#~extendState">为history.state增加/替换属性</a>
 * @property {function} replaceHash <a href="#~replaceHash">替换当前hash地址</a>
 * @property {function} getPage <a href="#~getPage">获取当前页面对应的容器</a>
 * @property {function} template <a href="#~template">获取模板函数</a>
 * @property {function} setTitle 设置title（可在m_bcd.app方法中初始化）
 * @property {function} reportError 异常上报（可在m_bcd.app方法中初始化）
 * @author liquidliang@tencent.com
 */
'use strict';

var m_is = __webpack_require__(1);
var m_url = __webpack_require__(2);
var m_time = __webpack_require__(3);
var m_history = __webpack_require__(4);
var m_isdebug = __webpack_require__(5);
var ajaxCache = __webpack_require__(6).ajaxCache;

var m_bcd = {
    is: m_is,
    url: m_url,
    ajaxCache: ajaxCache,
    history: m_history,
    extendState: m_history.extendState,
    isDebug: m_isdebug
};
var templateDict = {}; //用于缓存模板
var fileDict = {}; //目录索引，用于区分同名模板，以数字自增重命名

var getScrollY = m_bcd.getScrollY = function () { 
//参考 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollY
    return window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop;
}
//默认设置title函数，可在m_bcd.app方法中赋予默认值
m_bcd.setTitle = function(str) {
    document.title = str;
};
//默认设置异常上报函数，可在m_bcd.app方法中赋予默认值
m_bcd.reportError = function(exception, desc) {
    if(desc){
        console.log('%c--' + desc + '--', 'color: red;');
    }
    if(m_isdebug){
        console.debug(exception.stack);
    }    
};

var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
};
var _testRegexp = /[<'>"&`]/;
var _replaceRegexp = /[<'>"&`]/g;
m_bcd.escape = function(s) {
    return _testRegexp.test(s) ? s.replace(_replaceRegexp, function(c) {
        return escapeMap[c];
    }) : ''+(s||'');
}


function getTemplate(srcStr, name) {
    try {
        return new Function("obj, config", "var p=[],print=function(){p.push.apply(p,arguments);}, BCD=this;\n" +
            // 转换模板为js代码
            "p.push('" +
            srcStr.replace(/[\n\r]/g, ' ')
            .replace(/<%\s*-(.*?)%>/g, "',BCD.escape($1),'")
            .replace(/<%\s*=(.*?)%>/g, "',$1,'")
            .replace(/<%/g, "');\n")
            .replace(/%>\s*/g, "\np.push('") +
            "');\nreturn p.join('');" + (m_isdebug ? "\n//# sourceURL=t://template/" + name : "")).bind(m_bcd);
    } catch (e) {
        m_bcd.reportError(e, 'template wrong!');
        return function() {};
    }

}

/**
 * @function template
 * @description 获取模板函数，注意：模板字符串使用单引号引起来，如果模板字符串中必须包含单引号，则使用：\\\'
 * @param  {string} srcStr 类似于underscore的模板字符串
 * @param  {string} [name]   模板名
 * @return {templateFun}  模板函数
 */
/**
 * @function templateFun
 * @param  {object} obj     通常是通过ajax请求到的json数据
 * @param  {object} config   由于ajax数据可能不足以渲染模板，以config作为补充
 * @return {string}   生成的字符串
 */
m_bcd.template = function(srcStr, name) {
    name = name || 'undefined/';
    var template;
    var subDict = templateDict[name];
    if (name in fileDict) {
        template = subDict[srcStr];
    } else {
        subDict = templateDict[name] = {};
        fileDict[name] = -1;
    }
    if (!template) {
        name += (++fileDict[name]) || '';
        template = subDict[srcStr] = getTemplate(srcStr, name);
        template.viewName = name;
    }
    return template;
};

var eventDict = {}; //事件词典
/**
 * @function addEvent
 * @description 注册新事件（或称“指令”），注意非全局事件，最好使用模块名的命名空间避免冲突
 * @param {string} key 事件名/指令名
 * @param {bindFun} fun <a href="#~bindFun">处理函数，在处理函数里面可以包含绑定事件的处理</a>
 */
/** 被注册的回调函数
 * @callback bindFun
 * @param {element} [ele] 使用了该指令的dom对象
 * @param {object} [options] 元素的data-on属性值序列化成的对象
 * @param {object} [data] 渲染view的数据
 */
m_bcd.addEvent = function(key, fun) {
    if (key in eventDict) {
        m_bcd.reportError(new Error('The event "' + key + '" already exists, rename it!', 'addEvent'));
    }
    eventDict[key] = fun;
};
/**
 * @function bindEvent
 * @description 事件绑定，扩展zepto，遍历包含data-on属性的元素，使用已注册事件/指令对该元素进行处理
 * @param  {object} data 数据
 */
$.fn.bindEvent = m_bcd.bindEvent = function(data) {
    var _dom = $(this);
    _dom.find('[data-on]').each(function() {
        var ele = $(this);
        var bindFun, option = {};
        var action = ele.attr('data-on');
        if (action) {
            try {
                option = m_url.getParamObj(action);
                bindFun = eventDict[option.m];
                if (bindFun) {
                    option.url = ele.attr('data-url'); //由于url参数需要编码解码比较麻烦，因此用另一个属性较为方便（使用时看情况设置该属性）。
                    bindFun(ele, option, data);
                    ele.removeAttr('data-on');
                }
            } catch (e) {
                m_bcd.reportError(e, 'bindEvent action "' + action);
            }
        }
    });
    return _dom;
};

/**
 * @function setView
 * @description 块视图，扩展zepto，负责dom渲染及相关事件绑定。在view render结束的时候会触发reset事件，注意会冒泡，需要判断事件target==this
 * @param {object} options 配置参数
 * @param {string} [options.url] 是ajax请求的url，通过该url获得用于填充模板的数据
 * @param {object} [options.data] 用于填充模板的数据，用于填充模板，如果传入了data字段，则忽略url字段。
 * @param {object} [options.config] 用于填充模板的其他数据，与data一起参与模版渲染，由于ajax请求回来的数据可能不足以渲染模板，因此提供该参数作为补充。
 * @param {function} [options.getData] 获取更新数据的方式
 * @param {string} [options.update] 更新频率
 * @param {string|function} [options.template]  用于生成模板函数的字符串或模板函数
 * @param {string} [options.name]   view名同时也是模板函数生成的文件名
 * @param {array} [options.viewList] 关联的子view列表，在该view进行reset时会对关联的子view分别进行reset
 * @param {function} [options.start]  初始化函数，reset时最先执行，如果函数返回字符串“show”则直接跳到最后的处理过程。
 * @param {function} [options.end]  渲染结束执行的函数，如果函数返回字符串“hide”则view不展示
 * @param {function} [options.filter]  数据过滤，返回值用于渲染模板。
 * @param {function} [options.check=function(preData){return preData && preData.ret === 0;}] 数据校验函数，渲染结束时调用，如果返回false，则不缓存拉取到的数据。
 * @param {function} [options.error]  ajax请求失败回调函数
 * @param {string} [options.full="html"]  填充方式，可以是html、append、prepend、text等
 * @param {number} [options.timeout]  超时毫秒数
 * @param {boolean} [options.withCredentials]  是否跨域带cookie
 * @param {boolean} [options.delay]  是否忽略由框架控制reset，默认为false
 * @param {string} [options.show]  当前dom的展示顺序，"first"：在其子view进行reset之前调用end方法，“hide”：不调用end方法，默认“finish”：在其子view进行reset之后调用end方法
 * @param {string} [options.cache="normal_local"]     缓存使用方式：
 * <p>"normal_local" 表示如果数据有效则直接使用，超过有效期则拉取失败时使用缓存， 缓存在localStorage中；</p>
 * <p>"reload_local 表示先用缓存，当拉取回来时再用新数据render， 缓存在localStorage中；</p>
 * <p>"next_local    表示如果有缓存，则用缓存，但会拉取新数据不render，下次再用， 缓存在localStorage中；</p>
 * <p>"normal_session 表示如果数据有效则直接使用，超过有效期则拉取失败时使用缓存， 缓存在sessionStorage中；</p>
 * <p>"reload_session 表示先用缓存，当拉取回来时再用新数据render， 缓存在sessionStorage中；</p>
 * <p>"next_session    表示如果有缓存，则用缓存，但会拉取新数据不render，下次再用， 缓存在sessionStorage中；</p>
 * @return {$}
 */

$.fn.setView = function(opt) {
    var _dom = this;
    var dom = _dom[0];
    if (!dom) {
        m_bcd.reportError(new Error('the dom is not exit in html'), 'domError');
        return;
    }
    var options = dom.BCD_viewOption || {};
    if (options.__isInit) {
        $.extend(options, opt);
    } else {
        (function() {
            var preData, saveCache, fullMethod, hashRender = false,
                fullData, useCache;

            options = dom.BCD_viewOption = $.extend({}, opt);
            options.__isInit = true;
            options.cache = options.cache || 'normal_local';

            function buildFrame() {
                (options.viewList || []).forEach(function(ele, i) {
                    if (ele && ele.reset) {
                        if (!(ele[0] && ele[0].parentNode && ele[0].parentNode.nodeType === Element.ELEMENT_NODE)) {    //ele.index() < 0
                            _dom.append(ele);
                        }
                        if (!ele.getViewOption('delay')) {
                            ele.reset();
                        }
                    } else {
                        m_bcd.reportError(new Error('viewList index=' + i + ' is wrong value!'));
                    }
                });
                hashRender = true;
                return _dom.bindEvent(fullData);
            }

            function endFun() {
                if (_dom.attr('data-page')) {
                    var page = m_bcd.getPage();
                    if (page && page[0] !== dom) {
                        return; //避免ajax异步回包前发生页面切换
                    }
                }
                if (!(options.end && options.end.call(_dom, preData, options) == 'hide')) {
                    _dom.show().trigger('show');
                }
            }

            function show(name) {
                _dom.attr('data-view', name);
                if (options.show === 'first') {
                    endFun();
                    buildFrame();
                } else if (options.show === 'hide') {
                    buildFrame();
                } else {
                    buildFrame();
                    endFun();
                }
            }

            function render(data, doit, oldOption, cacheData) {
                try {
                    var tpl, check, innerHtml;
                    if (!(doit && options.cache.indexOf('next') === 0)) { //通过缓存决定是否重新渲染，doit=1表示已渲染过1次
                        if (m_is.s(options.template)) {
                            tpl = m_bcd.template(options.template, options.name || _dom.attr('data-view'));
                        } else {
                            tpl = options.template;
                        }
                        preData = data;
                        fullData = options.filter ? options.filter.call(_dom, data, options, cacheData) : data;
                        if (tpl) {
                            innerHtml = tpl(fullData, options.config || {});
                            _dom[fullMethod](innerHtml);
                        }
                        check = options.check || function(preData) {
                            return preData && preData.ret === 0;
                        };
                        show(tpl.viewName);
                        if (!check) {
                            return 0;
                        } else if (!check.call(_dom, preData, options)) {
                            return 0;
                        }
                    }
                    return options.cache.indexOf('local') > 0 ? 1 : 2;
                } catch (e) {
                    m_bcd.reportError(e, ('view render "'+(tpl && tpl.viewName) || options.name) + '" has wrong ' + (options.url ? 'ajax:' + options.url : 'data'));
                } finally {
                    _dom.trigger('reset', {
                        data: preData,
                        options: options
                    });
                }
            }

            function fetch(url_data) {
                if (url_data && m_is.s(url_data)) { //只对url进行判断，对象引用判断比较复杂，而且没意义
                    if (options.update && !m_url.getParam('t', url_data)) {
                        url_data = m_url.setParam('t', m_time.get(options.update || 't'), url_data);
                    }
                    options.url = url_data;
                    saveCache = ajaxCache.call(_dom, {
                        url: url_data,
                        success: render,
                        error: options.error,
                        timeout: options.timeout,
                        useCache: useCache,
                        xhrFields: {
                            withCredentials: !!options.withCredentials
                        }
                    });
                } else {
                    render(url_data, 0, options, preData);
                }
            }
            options.__getData = function() {
                return preData || options.data;
            };
            options.__setData = function(data) {
                var state = render(data || preData, 0, options, preData);
                if (m_is.f(saveCache)) {
                    saveCache(data, state);
                }
            };
            options.__reset = function(urlOrData) {
                try {
                    if (options.start && options.start.call(_dom, hashRender, options, urlOrData) === 'show') {
                        endFun();
                        return _dom;
                    }
                    useCache = m_history.getCode() == -1 || options.cache.indexOf('normal') !== 0; //返回要用缓存以便于锚点返回
                    if (options.template) {
                        fullMethod = options.full || 'html';
                        if (fullMethod == 'html' && !useCache) {//此处可以优化
                            _dom.hide();
                        }
                        var getData = options.getData || function() {
                            return options.data ? options.data : options.url || preData;
                        };
                        urlOrData = urlOrData || getData.call(_dom, hashRender, options); //urlOrData || options.data || options.url;            
                        fetch(urlOrData);
                    } else {
                        show('container');
                    }
                } catch (e) {
                    m_bcd.reportError(e, options.name + ' reset');
                }
                return _dom;
            };
        })();
    }
    return _dom;
};
/**
 * @function getViewOption
 * @description 扩展zepto，获取view设置
 * @param  {string} [key] 属性名，不传则得到view的options
 * @return {object}     属性值
 */
$.fn.getViewOption = function(key) {
    if (!this[0]) return null;
    var options = this[0].BCD_viewOption = this[0].BCD_viewOption || {};
    return key ? options[key] : options;
};
/**
 * @function reset
 * @description 扩展zepto，重新渲染view
 * @param  {string|object} urlOrData 链接或数据
 * @return {zepto}  自身对象
 */
$.fn.reset = function(urlOrData) {
    var option = this.getViewOption();
    var reset = option && option.__reset;
    if (reset) {
        return reset(urlOrData);
    } else {
        $(this).bindEvent().show();
    }
    return this.bindEvent();
};
/**
 * @function getData
 * @description 扩展zepto，取出用于渲染view模板的数据
 * @return {object}  用于渲染view模板的数据
 */
$.fn.getData = function() {
    var getData = this.getViewOption().__getData;
    if (getData) return getData();
    return null;
};
/**
 * @function setData
 * @description 扩展zepto，用新数据渲染view模板
 * @param  {object} data 用于渲染view模板的数据
 * @return {zepto}  自身对象
 */
$.fn.setData = function(data) {
    var setData = this.getViewOption().__setData;
    if (setData) setData(data);
    return this;
};

/**
 * @function addView
 * @description 扩展zepto，为容器添加view
 * @param  {zepto} dom view
 * @return {object}     容器自身
 */
$.fn.addView = function(dom) { //setViewOption
    var viewList = this.getViewOption('viewList') || [];
    viewList.push(dom);
    return this.setView({
        viewList: viewList
    });
};
/**
 * @function removeView
 * @description 扩展zepto，为容器删除view
 * @param  {zepto} 单个dom view，即length==1
 * @return {object}     容器自身
 */
$.fn.removeView = function(dom) { //setViewOption
    var viewList = this.getViewOption('viewList') || [];
    return this.setView({
        viewList: viewList.filter(function(item) {
            if (dom[0] === item[0]) {
                item.remove();
                return false;
            }
            return true;
        })
    });
};
$.fn.getPage = function() {
    return this.data('page') ? this : $(this.parents('[data-page]')[0]);
};
/**
 * @function getView
 * @description 扩展zepto，获得zepto元素所在的view
 * @return {zepto}     view
 */
$.fn.getView = function() {
    return this.data('view') ? this : $(this.parents('[data-view]')[0]);
};

/**
 * 获取hash参数数组
 * @return {array} 获取哈希数组
 */
m_bcd.getHash = function(index) {
    return location.hash.split('/').slice(1)[index];
};
/**
 * @function app 
 * @description 程序入口, 主要是页面路由
 * @param {object} options 配置参数
 * @param {string} [options.initHTML] 是初始填充body标签的html内容
 * @param {function} [options.initPage] 页面初始的函数，在hash切换时发现不存在相应data-page命名的dom时调用
 * @param {function} [options.setTitle] 标题设置函数，会在页面渲染完的时候调用
 * @param {string} [options.defHash] 默认hash地址
 * @param {function} [options.reportError] 异常上报函数
 * @param {function} [options.logPV] PV上报函数，会在页面切换时调用
 * @example
//对于设置了data-page属性的html页面，可以只用
var m_bcd = require('bcd');
m_bcd.app();
* @example
//对于动态生成的页面
m_bcd.app({
    initPage: function(key, next) {
        var page = this;
        switch (key) {
            case 'hello':
                page.setView({
                    title: 'hello word',
                    viewList: [$('<h1>你好！</h1>')]
                });
                next();
                break;
            default://默认hash路径
                m_bcd.replaceHash('#!/hello');
                next(-1);
                break;
        }
    }
});
 */
var currentPage;
/**
 * @function getPage
 * @description 获取当前页面对应的容器
 * @return  {zepto} 当前页面对应的容器
 */
m_bcd.getPage = function() {
    return currentPage || $('body');
};
m_bcd.app = function(options) {
    var pages = $('[data-page]');
    var pageDict = {};
    var initPage = null;
    if (pages.length) {
        pages.each(function() {
            var ele = $(this);
            pageDict[ele.attr('data-page')] = ele.hide();
        });
    }

    currentPage = $(pages[0]);
    var defHash = '#!/' + currentPage.attr('data-page');
    var logPV = function() {
        console.log('logPV');
    };

    if (options) {
        if (options.initHTML) {
            document.body.innerHTML = options.initHTML;
        }
        initPage = options.initPage;
        m_bcd.setTitle = options.setTitle || m_bcd.setTitle;
        defHash = options.defHash || defHash;
        m_bcd.reportError = options.reportError || m_bcd.reportError;
        logPV = options.logPV || logPV;
    }

    function showPage(page) {
        if (document.activeElement && document.activeElement.blur) {
            document.activeElement.blur();
        }
        if (m_history.getCode() != -1) {
            scrollTo(0, 0); //避免受到之前页面的滚动位置的影响
        }
        m_bcd.setTitle(page.getViewOption('title') || '');
        page.reset(); //普通的dom
        logPV();
    }
    //路由，页面切换
    function changePage(hash) {
        currentPage.hide().trigger('hide');
        var key = m_bcd.getHash(0) || 'undefined';
        var page = pageDict[key];
        if (page) {
            currentPage = page;
            showPage(page);
        } else if (initPage) {
            currentPage = page = $('<div data-page="' + key + '"></div>');
            initPage.call(page, key, function(match) {
                if (match !== -1) {
                    $('body').append(page);
                    pageDict[key] = page;
                    showPage(page);
                }
            });
        } else {
            m_bcd.replaceHash(defHash);
        }
    }

    function main() {
        changePage(location.hash);
    }

    /**
     * @function replaceHash
     * @description 替换当前hash地址，支持小说书城首页类似tab切换的需求
     * @param  {string} hash 新的hash地址
     */
    m_bcd.replaceHash = function(hash) {
        m_bcd.extendState({
            scrollY: getScrollY() //所有主流浏览器都支持 pageXOffset 和 pageYOffset 属性。
        }, hash);
        m_history.replace();
        changePage(hash);
    };

    m_history.bindPopState(main);
};

m_bcd.Events = {
    _callFun: function(key) {
        if (key in this._events) {
            this._events[key].apply(this, arguments);
        }
    },
    _forFun: function(callback, args) {
        var strOrReg = args[0];
        if (m_is.s(strOrReg)) {
            callback.apply(this, args);
        } else {
            var reg = /.*/;
            args = [].slice.call(args);
            if (m_is.r(strOrReg)) {
                reg = strOrReg;
            } else {
                args.unshift(reg);
            }
            for (var key in this._events) {
                if (reg.test(key)) {
                    args[0] = key;
                    callback.apply(this, args);
                }
            }
        }
        return this;
    },
    on: function(key, callback) {
        this._events = this._events || {};
        this._events[key] = callback;
        return this;
    },
    off: function(strOrReg) {
        if (this._events) {
            return this._forFun.call(this, function(key) {
                delete this._events[strOrReg];
            }, arguments);
        }
        return this;
    },
    trigger: function(strOrReg /*options*/ ) {
        if (this._events) {
            return this._forFun.call(this, this._callFun, arguments);
        }
        return this;
    }
};




m_bcd.Model = function(data) {
    var _data = data;

    this.set = function(key_data, value) {
        if (arguments.length === 2) {
            _data = _data || {};
            _data[key_data] = value;
        } else {
            _data = key_data;
        }
        return this;
    };

    this.get = function(key) {
        return key ? (_data && _data[key]) : _data;
    };
    $.extend(this, m_bcd.Events);
};



m_bcd.scrollY = new m_bcd.Model();
var preScrollY = getScrollY();
window.onscroll = function(e) {
    var _scrollY = getScrollY();
    m_bcd.scrollY.trigger(new RegExp(m_bcd.getHash(0) + '\/?.*'), _scrollY, preScrollY);
    preScrollY = _scrollY;
};
/**
 * @function go
 * @description 页面跳转（所有页面跳转都应该使用该函数）
 * @param  {string} href  将跳转到的地址
 * @param  {string} [state] 记录当前页面history.state状态
 */
m_bcd.go = function(href, state) {
    m_bcd.extendState({
        scrollY: getScrollY()
    });
    m_history.go(href, state);
};
$(window).on('error', function(e) {
    var err = e.error || e;
    m_bcd.reportError(err, 'windowError');
});
module.exports = m_bcd;

/***/ },
/* 1 */
/***/ function(module, exports) {

/**
* @module {object} is 类型判断
* @return {function} 返回首字母大写的字符串，如果是数组, 返回'Array'，相应的判断方法为is.a()
* @property {function} o 通过typeof判断是否为对象
* @property {function} s 判断是否为字符串
* @property {function} b 判断是否为Boolean
* @property {function} n 判断是否为数字
* @property {function} f 判断是否为函数
* @property {function} u 判断是否为undefined
* @property {function} nl 判断是否为null
* @property {function} a 判断是否为数组
* @property {function} d 判断是否为Date类型
* @property {function} r 判断是否为正则表达式
* @example
* var m_is = require('is');
* console.info(m_is([]));    // "Array"
* console.info(m_is.a([]));    // "true"
* @author liquidliang@tencent.com
*/
'use strict';

/**类型判断，返回首字母大写的字符串，如果是数组, 返回'Array'，相应的判断方法为is.a()
 * @method is
 * @param {Object} o 为任意的已声明变量
 * @return {String} str typeMap中相应的key。
 */
function is(o) {
    return Object.prototype.toString.call(o).slice(8, -1);
}
var typeMap = {
    'String': 's',
    'Boolean': 'b',
    'Number': 'n',
    'Function': 'f',
    'Undefined': 'u',
    'Null': 'nl',
    'Array': 'a',
    'Date': 'd',
    'RegExp': 'r'
};

function isType(k) {
    return function(o) {
        return is(o) == k;
    };
}
for (var k in typeMap) {
    is[typeMap[k]] = isType(k);
}
is.o = function(o) {
    return typeof o === "object";   //这里用typeof判断object，如果为false，则为字符串、数字、undefined，boolean，无法为这些类型添加属性
};
/* 对象的判断，暂时没有合适的情景
    is.o = function(o) {
    return !typeMap[is(o)];
    };
     */

module.exports = is;

/***/ },
/* 2 */
/***/ function(module, exports) {

/**
 * @module {object} url URL相关函数
 * @description 依赖于zepto或jquer 的$
 * @return {object} 方法集合
 * @property {function} abs 获取绝对地址
 * @property {function} separateTime 把请求地址的‘t’参数值取出来
 * @property {function} getParamObj 参数对象
 * @property {function} getParam 获取参数值
 * @property {function} setParam 设置参数值
 * @property {function} removeParam 去掉参数
 * @author liquidliang@tencent.com
 */
'use strict';

function parser(url) {
    var arr = url.match(/([^#?]*)(\??[^#]*)(#?.*)/);
    return arr ? arr.slice(1) : [url];
}

//可处理：a=1&b=2&c=3这样格式的parament字符串
//value=false,不改变url值，value=undefined,删掉参数值， value为其他值则改变参数值
function process(key, value, parament) {
    var hasKey, oldValue;
    parament = parament.replace(new RegExp('([&?#])' + key + '=([^&#]*)(&?)'), function($0, $1, $2, $3) {
        oldValue = $2;
        if (value === false) {
            return $0;
        }
        hasKey = true;
        return value === undefined ? ($3 ? $1 : '') : ($1 + key + '=' + value + $3);
    });
    return {
        value: oldValue,
        hasKey: hasKey,
        parament: parament
    };
}
/**
//允许parament中包含重复key的版本， 从性能上不建议使用，在业务中避免包含重复key
function process(key, value, parament) {
    var hasKey, oldValue;
    parament = parament.replace(new RegExp('([&?#]?)' + key + '=([^&#]*)(&?)', 'g'), function($0, $1, $2, $3) {
        if(hasKey){
            return $3 ? $1 : '';
        }else{
            oldValue = $2;
            if (value === false) {
                return $0;
            }
            hasKey = true;
            return value === undefined ? ($3 ? $1 : '') : ($1 + key + '=' + value + $3);            
        }
    });
    if(parament.endsWith('&')){//在parament中包含同一个的多个值时可能会出现最后一个字符为&的情况
        parament = parament.slice(0, -1);
    }
    return {
        value: oldValue,
        hasKey: hasKey,
        parament: parament
    };
}
 */
/*
idx=1表示对search进行处理，idx=2表示对hash进行处理
 */
function processURL(key, value, url, idx) {
    idx = idx || 1;
    var arr = parser((url || location.href));
    var obj = process(key, value, arr[idx]);
    arr[idx] = obj.parament;
    obj.arr = arr;
    return obj;
}

function separateTime(url) {
    var p_url = processURL('t', undefined, url, 1);
    return {
        time: p_url.value||'',
        name: p_url.arr.join('')
    };
}

var _div = $('<div><a href=""/></a></div>')[0];
var _link = _div.firstChild;
var locObj = getParamObj(location.href); //当前location.href的search参数

function abs(url) { //这里使用单例，是考虑到js是单线程的
    _link.href = url;
    return _link.href;
}
/*
function data2param(_dict) {
    var strarr = [];
    for (var key in _dict) {
        strarr.push(key + '=' + _dict[key]);
    }
    return strarr.join('&');
}
*/
//获取URL参数
function getParamObj(url) {
    if (!url) {
        return locObj;
    }
    var _dict = {};
    var arr = parser(url);
    if (arr[1]) {
        arr = arr[1].substr(1).split(/[=&]/);
        var len = arr.length / 2;
        for (var i = 0; i < len; i++) {
            _dict[arr[i * 2]] = arr[i * 2 + 1];
        }
    }
    return _dict;
}


function getParam(key, url, idx) {
    return processURL(key, false, url, idx).value;
}

function setParam(key, value, url, idx) {
    idx = idx || 1;
    var map = ['&', '?', '#'];
    var p_url = processURL(key, value, url, idx);
    var arr = p_url.arr;
    if (!p_url.hasKey) {
        arr[idx] += (arr[idx].length===1 ? '' : map[arr[idx] ? 0 : idx]) + key + '=' + value;
    }
    return arr.join('');
}

function removeParam(key, url, idx) {
    return processURL(key, undefined, url, idx).arr.join('');
}

//idx 1表示search， 2表示hash
module.exports = {
    abs: abs,
    parser: parser,
    process: process,
    separateTime: separateTime,
    getParamObj: getParamObj,
    getParam: getParam,
    setParam: setParam,
    removeParam: removeParam
};

/***/ },
/* 3 */
/***/ function(module, exports) {

/**
 * @module {object} time  时间相关
 * @description 提供原核心函数支持
 * @return {object} 方法集合
 * @author mingqiuliao@tencent.com
 *                liquidliang@tencent.com
 */
'use strict';

//Unix时间转化为正常时间
function alignDate(val) {
    return val > 9 ? val : "0" + val;
}

var methodMap = {
    y: "getFullYear",
    M: "getMonth",
    d: "getDate",
    h: "getHours",
    m: "getMinutes",
    s: "getSeconds",
    t: "getTime"
};

function get(method, date) {
    return (date || new Date())[methodMap[method]]();
}

function formatDate(date, formatStr) {
    return formatStr.replace(/%[yMdhmst]/g, function(item) {
        var num = get(item[1], date);
        return alignDate(item === '%M' ? 1 + num : num);
    });
}

module.exports = {
    get: get,
    formatDate: formatDate,
    methodMap: methodMap
};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @module {object} history 历史栈状态管理
 * @author liquidliang@tencent.com
 */
'use strict';

var m_is = __webpack_require__(1);
var m_url = __webpack_require__(2);

/** 
 * code 的6种状态：-1后退；0刷新；1前进；2打开；3首次进入; 4 repalceState
 * 注意：IOS在多页面间跳转无法区分刷新和前进，都认为是刷新。（IOS都会执行一遍js，并触发popstate，而这里避免了这种popstate触发时的回调）
 */

var code = 3;
var historyVariable = {
    list: [{
        isBegin: 1,
        href: document.referrer
    }],
    isGo: 0
};
var historyList, lastPage;
var isPopstate = 0;
var curHash = location.hash;

function getLastIndex() {
    return historyList.length - 1;
}

if (history.state && history.state.historyVariable) { //如果没有这个判断，不用bcd框架的页面与用bcd框架页面来回跳，会出问题。
    historyVariable = history.state.historyVariable;
}
historyList = historyVariable.list; //历史路径  
lastPage = historyList[getLastIndex()].href;
//更新title状态
setInterval(function() {
    var state = historyList[getLastIndex()];
    if (state.title != document.title) {
        state.title = document.title;
        updateHistoryState();
    }
}, 500);
/**
 * @function extendState
 * @description 为history.state增加/替换属性
 * @param  {object} state 用于设置history.state的值
 * @param  {string} [hash]  用于history.replaceState的地址，不传则地址不变
 */
function extendState(state, hash) {
    state = $.extend({}, history.state, state);
    history.replaceState(state, null, hash || location.hash);
};


//打开页面
function pushState(state) {
    historyList.push(state);
    for (var i = 0, len = historyList.length; i < len; i++) {
        if (historyList[i].isBegin) {
            return historyList.splice(0, i);
        }
    }
}

function updateHistoryState() {
    extendState({
        historyVariable: historyVariable
    });
    //console.log('code='+code+'|lastPage='+lastPage);
}

//更新历史栈
function updateHistory() {
    var state = {
        href: location.href,
        title: document.title
    };
    var index = getLastIndex();
    if (index > 0) {
        if (historyList[index - 1].href == location.href) { //后退
            code = -1;
            historyList.unshift(historyList.pop());
        } else if (historyList[index].href == location.href) { //刷新
            code = 0;
            if (historyVariable.isGo) {
                code = 2;
            } else if (isPopstate) {
                code = 1;
            }
            historyList[index] = state;
        } else if (historyList[0].href == location.href) { //前进
            code = 1;
            historyList.push(historyList.shift());
        } else { //打开
            code = 2;
            pushState(state);
        }
    } else { //首次进入
        code = 3;
        historyList.push(state);
    }
    historyVariable.isGo = 0;
    updateHistoryState();
}


module.exports = {
    extendState: extendState,
    getCode: function() {
        return code;
    },
    get: function() {
        return historyList;
    },
    getLastPage: function() {
        return lastPage;
    },
    getState: function(index) {
        index = m_is.u(index) ? -1 : index;
        return historyList.slice(index)[0];
    },
    replace: function() {
        var index = getLastIndex();
        lastPage = historyList[index].href;
        historyList[index] = {
            href: location.href,
            title: document.title
        };
        code = 4;
        updateHistoryState();
    },
    go: function(href, state) { //在跳转到spa之外的页面，必须用go方法，不然返回时，无法正确判断，此时code=0，认为是刷新。
        lastPage = location.href;
        state = state || {};
        state.href = m_url.abs(href);
        historyVariable.isGo = 1;
        pushState(state);
        updateHistoryState();
        location.href = href;
    },
    /*  ios 8 */
    // 首次进入未触发'hashchange'，但触发了'popstate'事件，程序从头到尾执行一遍（刷新效果相同）；页面内进行hash变换（包括前进后退），会依次触发'popstate'和'hashchange'事件；从别的页面返回，和首次进入情景相同；从别的页面前进到当前页面，只触发了'popstate'事件，程序没有从头到尾执行一遍。
    // 如果前进后退切换的是不同的webview，将不触发'hashchange'和'popstate'事件，程序也不会从头到尾执行一遍
    /*  安卓QB6.0 、UC也一样*/
    //首次进入未触发'hashchange'，但会触发'popstate'事件，程序从头到尾执行一遍（刷新效果相同）；页面内进行hash变换（包括前进后退），会依次触发'popstate'和'hashchange'事件；从别的页面返回，只触发了'popstate'事件；从别的页面前进到当前页面，只触发了'popstate'事件，程序没有从头到尾执行一遍。刷新会重头到尾执行一遍且会触发popstate
    //ie 11 中亲测，都会触发hashchange，只有返回时触发popstate，且先触发popstate再触发hashchange，且不同页面间返回会从头到尾执行一遍
    //*/
    bindPopState: function(main) {
        if (!m_is.f(main)) return;
        var ua = navigator.userAgent || "";
        var initMain = 1;

        function showPage() {
            updateHistory();
            main();
        }
        if (/\(i[^;]+;( U;)? CPU.+Mac OS X/.test(ua)) {
            initMain = 0;
            //延时，避免移动端访问、IOS返回or刷新也触发popstate，导致两次渲染，如果产生了多次渲染，有可能是时间设短了
            setTimeout(function() {
                initMain = 1;
            }, 5000);
        }
        showPage();

        //如果是ie则用onhashchange
        window[ua.indexOf('Trident') > -1 ? 'onhashchange' : 'onpopstate'] = function() {
            if (initMain || curHash != location.hash) { //安卓返回时，curHref != location.hash 是false
                isPopstate = 1;
                showPage();
                curHash = location.hash;
                isPopstate = 0;
            }
        };
    }
};


/***/ },
/* 5 */
/***/ function(module, exports) {

/**
* @module {boolean} isdebug 判断代码是否被压缩
* @author liquidliang@tencent.com
*/
'use strict';

function isDebug(){
    var Debug;
}

module.exports = /Debug/.test(isDebug) || !!window.global_isDebug; //debug环境默认是未压缩的代码，返回true，压缩后，返回false

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

/**
 * @module {object} ajax 带本地缓存的ajax方法
 * @description 依赖于zepto或jquer 的$.ajax
 * @return {object} 方法集合
 * @property {function} ajax <a href="#~ajax">默认请求参数的ajax方法</a>
 * @property {function} ajaxCache <a href="#~ajaxCache">带缓存的ajax请求，约定ret=0为正确数据，可以缓存</a>
 * @author liquidliang@tencent.com
 */
'use strict';

var m_cache = __webpack_require__(7);
var m_url = __webpack_require__(2);
var m_is = __webpack_require__(1);
/**
 * 默认请求参数的ajax方法
 * @param  {object} options ajax选项
 */
function ajax(options) {
    var def = {
        dataType: 'json',
        timeout: 8e3
    };
    $.extend(def, options);
    $.ajax(def);
}

/**
 * 带缓存的ajax请求，约定ret=0为正确数据，可以缓存
 * @access public
 * @param {String | Object} url 请求地址，url中必须带有t参数作为缓存过期的判断标准。
 * @param {Function} [suc] 成功回调, 返回值number，如果是1，把数据存在localStorage中，2存在sessionStorage中，其他不保存
 * @param {Function} [err] 不成功回调
 * @param {Function} [timeOut] 超时时间
 * @param {int} [useCache]     缓存使用方式：       false 表示如果数据有效则直接使用，超过有效期则拉取失败时使用缓存；
 *                                                                             true 表示先用缓存，当拉取回来时再用新数据；
 * @return {Function} saveCache(data, state)保存数据的方法
 */
function ajaxCache(url_options, suc, err, timeOut, useCache) {
    var url = url_options;
    var options = url_options;
    if (m_is.s(url_options)) {
        options = {
            url: url
        };
        if (timeOut) options.timeout = timeOut;
    } else {
        url = options.url;
        suc = options.success;
        err = options.error;
        useCache = options.useCache;
    }
    var spurl = m_url.separateTime(url);
    var cValue = m_cache._get(spurl.name) || m_cache._getSession(spurl.name);
    var cData;
    var _this = this;
    var doit = 0; //用于控制本次数据是马上使用还是下次再用

    /**
     * 保存缓存数据
     * @param  {object} data  数据
     * @param  {number} state 状态
     */
    function saveCache(data, state) {
        var subAttr = cValue || {
            ct: spurl.time
        };
        if (spurl.time.length < 5) {
            subAttr.ct = spurl.time;
        }
        switch (state) {
            case 1: //使用localStorage
                m_cache.setLocal(spurl.name, data, subAttr);
                break;
            case 2: //使用sessionStorage
                m_cache.setSession(spurl.name, data, subAttr);
                break;
        }
    }

    function updateCache(cData) {
        options.success = function(data) {
            saveCache(data, suc.call(_this, data, doit, options, cData));
        };
        options.error = function() {
            if (!useCache || !cData) { //如果用缓存且cData存在，已经调过suc了
                if (m_is.f(err)) {
                    err.call(_this, cData, doit, options);
                } else {
                    suc.call(_this, cData, doit, options);
                }
            }
        };
        ajax(options);
    }

    var timeMatch;
    if (cValue) {
        cData = cValue.v;
        timeMatch = spurl.time && cValue.ct === spurl.time;
        if (useCache || timeMatch) {
            doit = 1;
            suc.call(_this, cData, doit, options);
        }
    }

    if (!timeMatch) {
        updateCache(cData);
    }

/*
    if (useCache) {
        if (cData) {
            suc.call(_this, cData, options);
            doit = 1;
        }
        updateCache(cData);
    } else if ((!cValue) || (spurl.time && cValue.ct != spurl.time)) { //如果没有带t参数或t参数为空则一直使用缓存！！
        updateCache(cData);
    } else {
        suc.call(_this, cData, options);
    }
*/
    return saveCache;
}

module.exports = {
    ajax: ajax,
    ajaxCache: ajaxCache,
};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

/**
* @module {object} common/bcd/cache 本地缓存管理
* @author liquidliang@tencent.com
*/
'use strict';

var m_is = __webpack_require__(1);
var m_json = __webpack_require__(8);

var _outdate = 1;
var _db = {};
var _now = parseInt(Date.now() / 3600000); //最小粒度是小时
function toObject(val, obj) {
    obj = obj || {};
    obj.t = _now;
    obj.v = val;
    return obj;
}

function setLocal(key, val, subAttr) {
    if(!subAttr){
        subAttr = getLocal(key);
    }
    var obj = toObject(val, subAttr);
    try {
        localStorage.setItem(key, JSON.stringify(obj));
    } catch (e) {
        if (subAttr && subAttr.isFail) {
            _db[key] = obj;
        } else {
            removeLocal(0, _now - _outdate);
            subAttr = subAttr || {};
            subAttr.isFail = 1;
            setLocal(key, val, subAttr);
        }
    }
}

function setSession(key, val, subAttr) {
    if(!subAttr){
        subAttr = getSession(key);
    }
    var obj = toObject(val, subAttr);
    try {
        sessionStorage.setItem(key, JSON.stringify(obj));
    } catch (e) { //由于sessionStorage的兼容性不如localStorage，如果是sessionStorage存满了，localStorage也会抛异常的。
        setLocal('BCD_db_' + key, val);
    }
}

function getLocal(key) {
    try {
        var val = localStorage.getItem(key);
        if (val) {
            return m_json.parse(val);
        } else {
            return _db[key];
        }
    } catch (e) {
        return _db[key];
    }
}

function getSession(key) {
    try {
        var val = sessionStorage.getItem(key);
        if (val) {
            return m_json.parse(val);
        } else {
            return getLocal('BCD_db_' + key);
        }
    } catch (e) {
        return getLocal('BCD_db_' + key);
    }
}

function matchTime(key, lasttime) { //只有localStorage才有用到
    var val = getLocal(key);
    return val && (!val.permanent) && val.t && val.t <= lasttime;
}

function match(reg, intervalTime) {
    var lasttime = _now - intervalTime;
    if (m_is.r(reg) && m_is.n(intervalTime)) {
        return function(key) {
            return matchTime(key, lasttime) && reg.test(key);
        };
    } else if (m_is.r(reg)) {
        return function(key) {
            return reg.test(key);
        };
    } else if (m_is.n(intervalTime)) {
        return function(key) {
            return matchTime(key, lasttime);
        };
    }
    return 0;
}

function removeLocal(reg, intervalTime) {
    try {
        if (m_is.s(reg)) {
            delete _db[reg];
            localStorage.removeItem(reg);
        } else {
            //按规则删除，只删除放在localStorage中的。
            var filterMethod = match(reg, intervalTime) || function(key) {
                var val = getLocal(key);
                return val && !val.permanent;
            };
            if (filterMethod) {
                for (var key in localStorage) {
                    //(m_is.n(intervalTime) && val.t && val.t <= (_now - intervalTime)) || (m_is.r(reg) && reg.test(key))
                    if (filterMethod(key)) {
                        localStorage.removeItem(key);
                    }
                }
            }
        }
    } catch (e) {}
}

function removeSession(reg) {
    try {
        if (m_is.s(reg)) {
            delete _db['BCD_db_' + reg];
            sessionStorage.removeItem(reg);
        } else {
            var filterMethod = match(reg);
            if (filterMethod) {
                for (var key in sessionStorage) {
                    if (filterMethod(key)) {
                        sessionStorage.removeItem(key);
                    }
                }
            }
        }
    } catch (e) {
        removeLocal(/^BCD_db_/);
    }
}
setTimeout(function() {
    removeLocal(/^BCD_db_/, 1); //把1小时前放在localStorage的session删掉
}, 5000);

module.exports = {
    setLocal: setLocal,
    setSession: setSession,
    _get: getLocal,
    getLocal: function(key, def) {
        var val = getLocal(key);
        return val ? val.v : def || null;
    },
    _getSession: getSession,
    getSession: function(key, def) {
        var val = getSession(key);
        return val ? val.v : def || null;
    },
    removeLocal: removeLocal,
    removeSession: removeSession
};

/***/ },
/* 8 */
/***/ function(module, exports) {

/**
* @module {object} json JSON相关（内部捕获异常）
* @return {object} 方法集合
* @property {function} parse 把json字符串转为对象
* @property {function} stringify 把普通对象序列化成json字符串
* @example
* var m_json = require('json');
* console.info(m_json.stringify(m_json.parse('{a: "hello"}')));    // '{a: "hello"}'
* @author liquidliang@tencent.com
*/
'use strict';

function parse(str) {
    try {
        return JSON.parse(str);
    } catch (e) {}
    return ''; //这里没有返回空对象，是因为空字符串可以在条件判断中认为false，同时点操作不会报错。
}

function stringify(o) {
    try {
        return JSON.stringify(o);
    } catch (e) {
        return "";
    }
}

module.exports = {
    parse: parse,
    stringify: stringify
};

/***/ }
/******/ ])
});
;