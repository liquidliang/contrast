# BCD框架与流行框架之间的性能比较
[项目地址][1]

在React流行之初，有不少实验比较，使用React操作虚拟DOM与使用Zepto操作真实的DOM之间的比较，以此来说明，React更优越。操作dom效率低，似乎成为了一种共识。然而，细想，这里面似乎存在一些猫腻，因为虚拟DOM操作的优势是来自于一系列的空操作。有一种感觉，他们在用React的上等马，和Zepto的下等马作比较。由此，得出结论说，React更好，云云。

实际业务中，正常的开发者，都会避免频繁地操作dom，只有在必要的时候才会去进行dom的操作（毕竟多操作一次就意味着多一行代码，除非无脑地把DOM操作放在循环里）。同时，一个交互，需要触发的DOM操作也是有限的。在我们的实践中，再频繁地操作DOM也很难超过10次每秒的频率。

为了让我们的框架与流行框架，更公平地进行比价。我们做了一个实验去研究这个问题，结论是“虚拟dom的框架，不会带来比直接操作dom的框架更好的性能”，反而可能带来更多的额外开销。

我们针对React、Vue、Backbone和我们的自研框架BCD，应用在同一个项目——todoMVC中进行比较。（其它3个框架的实现均来自todoMVC，我们进行了部分修改：去掉不需要的js和css、把jsx编译成js再使用）。基于BCD的实现，是绝对纯粹的MCV的实现，每个交互都会操作DOM，很多时候是innerHTML的修改。

由于这几个框架的体积有大有小，我们在本地进行这个实验，尽量避免由文件大小带来的差异。
实验分两部分：1、首屏渲染性能；2、进行一系列交互操作渲染性能。

###实验平台
![实验平台][2]


chrome版本： 52.0.2743.116 m

###准备工作

 1. 把项目克隆到本地
 2. 在chrome中打开隐身窗口，关闭其它浏览器窗口
 3. 在chrome上执行 Esc+ Shift调出“任务管理器”（也可以在菜单-更多工具中找到），把运行的插件都结束掉。
 4. 在项目中的public目录下把index.html拖入隐身窗口，进入导航页面。（本地测的好处是可以忽略网络IO对性能的影响，专注于渲染性能）
 5. 分别打开React、Vue、Backbone和BCD。
 6. 分别在以上页面中，右键-检查-Timeline
 7. Timeline的Capture，只勾选Memory(注意不要勾选JS Profile和Paint，捕获这两项数据会影响性能指标)

###首屏渲染性能比较
打开Timeline之后，每次刷新，都会自动录制。我们刷新3次，取表现最好的那一次的0-1s之间的数据，进行比较。
结果如下：
![首屏渲染时间][3]
 - Backbone		渲染占用时长 = 44.8+2.8+1.0 = 48.6 ms
 - BCD		渲染占用时长 = 20.4+2.5+0.9   = 23.8ms
 - React		渲染占用时长 = 131.0+1.2+0.7 = 132.9ms
 - Vue			渲染占用时长 = 49.1+2.0+2.4 = 53.5ms

###进行一系列交互操作渲染性能
我们分别对各个框架的todo进行如下步骤的操作：

 1. 输入：a
 2. 按回车键
 3. 输入：b
 4. 按回车键
 5. 输入：c
 6. 按回车键
 7. 勾选，b
 8. 双击c进入编辑状态，把c改成d，按回车键
 9. 删除a
 10. 点击Active，切换到active页面

操作前开始录制，操作完，停止录制。每组重复3次，得到的最好结果如下：
![操作渲染性能][4]

 - Backbone		渲染占用时长 = 83.9+68.3+19.9 =  182.1ms
 - BCD		渲染占用时长 =   79.2+54.0+26.9 = 160.1ms
 - React		渲染占用时长 = 159.5+50.5+22.4 = 232.4ms
 - Vue			渲染占用时长 = 86.8+59.9+27.3 = 174.0ms
 
 ###体积比较
 
 ![体积比较][5]

  [1]: https://github.com/qqbrowser/contrast
  [2]: http://cdn.liquidliang.cc/img/pc.png
  [3]: http://cdn.liquidliang.cc/img/spxrxn.png
  [4]: http://cdn.liquidliang.cc/img/czxrxn.png
  [5]: http://cdn.liquidliang.cc/img/bcdcontrast.png
